"""
    백준 1463번. 1로 만들기
    난이도: 실버 3
    알고리즘: 다이나믹 프로그래밍
    추가 설명:
        동적 계획법을 사용하는 문제로, 규칙을 찾기 힘든 문제의 경우 메모이제이션을 통해 값을 메모해 가며
        전 값들을 참조하여 문제를 풀 수 있게 한다.
        동적 계획법을 이용한 방법과, 내가 생각한 방법 두 가지로 풀어 봤음.
"""


def by_dynamic_programming():
    """동적 계획법을 이용한 방법이다.
    X=1일 때 경우의 수부터 입력받은 값까지 순서대로 메모하며 채워 넣는다.
    복잡도는 아마 O(n)인듯?(각 loop마다 숫자 연산뿐이므로 O(1) * O(n))
    실행 시간 : 백준 기준 480ms
    """
    X = int(input())
    L = [None, 0]  # 맨 처음 0은 인덱스의 편의를 위해 채워 둠, 그 다음 0은 L[1]로 X=1인 경우로, 0번의 연산으로 1이 될 수 있음.
    for i in range(2, X+1):
        temp = L[i-1]  # 1을 뺐을 때의 연산수
        if i % 2 == 0:
            temp = min(temp, L[i//2])  # 2로 나눴을 때의 연산수를 1을 뺐을 때의 연산수와 비교함
        if i % 3 == 0:
            temp = min(temp, L[i//3])  # 3으로 나눴을 때의 연산수와 비교함.
        L.append(temp + 1)  # 위에서 구한 가장 작은 연산수 + 1
    print(L[-1])

def by_brute_force():
    """한번 생각해본 방법으로, 그냥 3가지 연산 다 해보면서 내려가기. (BFS라 생각해도 될듯)
    동적 계획법과 달리, 모든 경우의 수를 다 해볼 필요는 없다
    그러나 최악의 경우, 연산이 3개 -> 9개 -> 27개 꼴로 연산량이 늘어날 수 있다. (n = "입력 x에 대한 연산 수" 이므로 O(3^n)은 아님)
    실행 시간 : 백준 기준 72ms
    """
    L = [int(input())]
    cnt = 0
    while 1 not in L:
        L2 = set()
        cnt += 1
        for i in L:
            L2.add(i-1)
            if i%2 == 0:
                L2.add(i//2)
            if i%3 == 0:
                L2.add(i//3)
        L = list(L2)
    print(cnt)

by_dynamic_programming()
# by_brute_force()
